<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>Serpent Sprint</title>
	<link rel="shortcut icon" href="./images/snake.ico" type="image/x-icon">
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<style>
		:root {
			--bg: #111;
			--panel: #1a1a1a;
			--snake: #3ddc97;
			--food: #ff6b6b;
			--grid: #222;
			--text: #eaeaea;
			--accent: #888;
		}

		* {
			box-sizing: border-box;
		}

		html,
		body {
			height: 100%;
			margin: 0;
			background: radial-gradient(1200px 600px at 70% 0%, #161616 0%, #0d0d0d 60%, #000 100%);
			color: var(--text);
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell,
				"Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
		}

		/* ---------- TITLE ---------- */

		.title {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 12px;
		}

		.title img {
			width: 50px;
		}

		.title img.flip {
			transform: scaleX(-1);
		}

		.title h1 {
			padding: 5px;
			font-family: cursive;
			font-size: 50px;
			background: linear-gradient(#011003, #65dc60);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			margin: 0;
		}

		/* ---------- LAYOUT ---------- */

		.wrap {
			width: 50%;
			margin: auto;
			min-height: 75%;
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			padding: 24px;
			align-items: center;
			justify-content: center;
		}

		.game {
			display: grid;
			gap: 12px;
			justify-items: center;
		}

		/* ---------- HUD ---------- */

		.hud {
			display: flex;
			gap: 16px;
			align-items: center;
			background: var(--panel);
			border: 1px solid #2a2a2a;
			padding: 8px 12px;
			border-radius: 10px;
			box-shadow: 0 8px 30px rgba(0, 0, 0, 0.35),
				inset 0 1px 0 rgba(255, 255, 255, 0.03);
		}

		.hud-item {
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 14px;
			color: var(--accent);
		}

		.hud-item b {
			color: var(--text);
			font-weight: 600;
		}

		/* ---------- GAME BOARD (FLUID) ---------- */

		.board-wrapper {
			position: relative;
			width: min(90vw, 420px);
			aspect-ratio: 1 / 1;
		}

		#board {
			width: 100%;
			height: 100%;
			display: block;
		}

		canvas {
			background: var(--bg);
			border-radius: 12px;
			border: 1px solid #222;
			box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5),
				inset 0 1px 0 rgba(255, 255, 255, 0.04);
		}

		.grid-bg {
			position: relative;
		}

		.grid-bg::after {
			content: "";
			pointer-events: none;
			position: absolute;
			inset: 0;
			background:
				linear-gradient(to right, var(--grid) 1px, transparent 1px),
				linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
			background-size: 20px 20px;
			border-radius: 12px;
			mix-blend-mode: lighten;
			opacity: 0.15;
		}

		/* ---------- OVERLAY ---------- */

		.overlay {
			position: absolute;
			inset: 0;
			display: none;
			place-items: center;
			backdrop-filter: blur(2px);
			text-align: center;
		}

		.overlay-content {
			background: rgba(20, 20, 20, 0.85);
			border: 1px solid #2a2a2a;
			padding: 16px 20px;
			border-radius: 12px;
			max-width: 280px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
		}

		.overlay-text {
			font-size: 16px;
			margin-bottom: 8px;
		}

		.overlay-hint {
			font-size: 13px;
			color: #bbb;
		}

		.btn {
			margin-top: 10px;
			padding: 8px 12px;
			border-radius: 8px;
			background: #2b2b2b;
			color: var(--text);
			border: 1px solid #3a3a3a;
			cursor: pointer;
		}

		.btn:hover {
			background: #333;
		}

		/* ---------- DRAWING CANVAS ---------- */

		.canvas {
			display: grid;
			gap: 12px;
			justify-items: center;
		}

		#canvas {
			border: 2px solid #333;
			background: black;
			cursor: crosshair;
			image-rendering: pixelated;
			touch-action: none;
		}

		.examples {
			display: flex;
			gap: 5px;
		}

		.examples img {
			width: 40px;
			height: 40px;
			border: 1px solid #fff;
		}

		.canvas button {
			height: 40px;
			width: 120px;
			font-size: 14px;
			background: var(--panel);
			color: var(--text);
			border-radius: 10px;
			cursor: pointer;
			border: 1px solid #3a3a3a;
		}

		/* ---------- HINT ---------- */

		.hint {
			font-size: 12px;
			color: var(--accent);
			text-align: center;
		}

		/* ---------- RESPONSIVE ---------- */

		@media screen and (max-width: 768px) {
			.title h1 {
				font-size: 22px;
			}

			.wrap {
				width: 70%;
				grid-template-columns: 1fr;
				grid-template-rows: auto auto;
			}

			.hud-item {
				font-size: 12px;
			}

			.board-wrapper {
				width: min(90vw, 280px);
			}

			.overlay-content {
				max-width: 200px;
			}

			.hint {
				font-size: 10px;
			}

			.overlay-hint {
				font-size: 10px;
			}

			.examples svg {
				height: 20px;
				width: 20px;
			}

			.canvas button {
				height: 30px;
				width: 120px;
			}
		}
	</style>
</head>

<body>
	<div class="title">
		<img src="./images/snake.svg" alt="Snake">
		<h1>Serpent Sprint</h1>
		<img src="./images/snake.svg" alt="Snake" class="flip">
	</div>

	<div class="wrap">
		<div class="game">
			<div class="hud">
				<div class="hud-item"><b>Score:</b> <span id="score">0</span></div>
				<div class="hud-item"><b>Best:</b> <span id="best">0</span></div>
				<div class="hud-item"><b>Speed:</b> <span id="speed">Normal</span></div>
			</div>

			<div class="board-wrapper">
				<canvas id="board" class="grid-bg" width="400" height="400"></canvas>

				<div class="overlay" id="overlay">
					<div class="overlay-content">
						<div id="overlayText" class="overlay-text">Paused</div>
						<div class="overlay-hint">
							Use arrow keys / WASD or draw ULDR to move • P to pause • R to restart • 1/2/3 to set speed
						</div>
						<button class="btn" id="resumeBtn">Resume</button>
					</div>
				</div>
			</div>

			<div class="hint">
				Use arrow keys / WASD or draw ULDR to move • Press P to pause • Press R to restart • 1/2/3 to change
				speed.
			</div>
		</div>

		<div class="canvas">
			<div class="examples">
				<img src="./images/example_D.svg" alt="example drawing D">
				<img src="./images/example_L.svg" alt="example drawing L">
				<img src="./images/example_R.svg" alt="example drawing R">
				<img src="./images/example_U.svg" alt="example drawing U">
			</div>
			<canvas id="canvas" width="256" height="256"></canvas>
			<button id="ping-button" type="button" onclick="ping()">Ping server</button>
		</div>
	</div>

	<script>
		// ################################# CANVAS LOGIC ###########################################
		const image_canvas = document.getElementById("canvas");
		const image_ctx = image_canvas.getContext("2d");

		// Resize canvas to match window size 
		function resizeCanvas() {
			if (window.innerWidth < 768) {
				image_canvas.width = 120;
				image_canvas.height = 120;
				image_ctx.width = 120;
				image_ctx.height = 120;
			}
			else {
				image_canvas.width = 256;
				image_canvas.height = 256;
				image_ctx.width = 256;
				image_ctx.height = 256;
			}

		}
		// Call once and also on resize 
		resizeCanvas();
		window.addEventListener('resize', resizeCanvas);

		image_ctx.lineCap = "round";
		image_ctx.strokeStyle = "white";

		let drawing = false;

		// Mouse events
		image_canvas.addEventListener("mousedown", (e) => {
			drawing = true;
			image_ctx.beginPath();
			image_ctx.moveTo(e.offsetX, e.offsetY);
		});

		image_canvas.addEventListener("mousemove", (e) => {
			if (!drawing) return;
			image_ctx.lineWidth = 6;
			image_ctx.lineTo(e.offsetX, e.offsetY);
			image_ctx.stroke();
		});

		image_canvas.addEventListener("mouseup", () => {
			drawing = false;
			predict()
		});

		image_canvas.addEventListener("mouseleave", () => {
			drawing = false;
		});

		function clearCanvas() {
			image_ctx.fillStyle = "black";
			image_ctx.fillRect(0, 0, image_canvas.width, image_canvas.height);
		}

		function simulateKeyPress(key) {
			const event = new KeyboardEvent("keydown", {
				key: key,
				code: key,
				bubbles: true
			});
			document.dispatchEvent(event);
		}

		function getTouchPos(canvas, touch) {
			const rect = canvas.getBoundingClientRect();
			return {
				x: (touch.clientX - rect.left) * (canvas.width / rect.width),
				y: (touch.clientY - rect.top) * (canvas.height / rect.height)
			};
		}

		image_canvas.addEventListener("touchstart", (e) => {
			e.preventDefault(); // stop page scroll
			drawing = true;

			const touch = e.touches[0];
			const pos = getTouchPos(image_canvas, touch);

			image_ctx.beginPath();
			image_ctx.moveTo(pos.x, pos.y);
		}, { passive: false });

		image_canvas.addEventListener("touchmove", (e) => {
			if (!drawing) return;
			e.preventDefault();

			const touch = e.touches[0];
			const pos = getTouchPos(image_canvas, touch);

			image_ctx.lineWidth = 6;
			image_ctx.lineTo(pos.x, pos.y);
			image_ctx.stroke();
		}, { passive: false });

		image_canvas.addEventListener("touchend", (e) => {
			e.preventDefault();
			drawing = false;
			predict();
		}, { passive: false });

		image_canvas.addEventListener("touchcancel", () => {
			drawing = false;
		});



		function predict() {
			let url = "http://localhost:9696/predict"    // for local hosting
			url = "https://snake-game-letter-cnn.onrender.com/predict"
			fetch(url, {
				method: "POST",
				headers: {
					"Content-Type": "application/json"
				},
				body: JSON.stringify({
					img: image_canvas.toDataURL()
				})
			})
				.then(res => res.json())
				.then(data => {
					const maxKey = Object.keys(data).reduce((a, b) => data[a] > data[b] ? a : b);
					if (maxKey == "L") simulateKeyPress("ArrowLeft")
					else if (maxKey == "U") simulateKeyPress("ArrowUp")
					else if (maxKey == "R") simulateKeyPress("ArrowRight")
					else if (maxKey == "D") simulateKeyPress("ArrowDown")
				})
				.catch(err => console.error(err));
			clearCanvas()
		}

		function ping() {
			const ping_btn = document.getElementById("ping-button");
			ping_btn.setAttribute("disabled", true);
			ping_btn.innerText = "Please wait...";
			const data = image_canvas.toDataURL()
			clearCanvas()

			let url = "http://localhost:9696/predict"
			url = "https://snake-game-letter-cnn.onrender.com/predict"
			fetch(url, {
				method: "POST",
				headers: {
					"Content-Type": "application/json"
				},
				body: JSON.stringify({
					img: data
				})
			})
				.then(res => res.json())
				.then(data => {
					ping_btn.style.color = "#00ff00";
					ping_btn.innerText = "Server OK";
					setTimeout(() => {
						ping_btn.style.color = "#ffffff";
						ping_btn.innerText = "Ping Server";
						ping_btn.removeAttribute("disabled");
					}, 3000)

				})
				.catch(err => {
					ping_btn.style.color = "#ff0000";
					ping_btn.innerText = "Server Down";
					console.error(err);
					setTimeout(() => {
						ping_btn.style.color = "#ffffff";
						ping_btn.innerText = "Ping Server";
						ping_btn.removeAttribute("disabled");
					}, 3000)
				});
		}

		// ################################# GAME LOGIC ###########################################
		// Config
		const CELL = 20;            // pixel size per cell
		const GRID = 20;            // 20x20 grid -> canvas 400x400
		const START_LEN = 4;
		const COLORS = { snake: "#3ddc97", food: "#ff6b6b", head: "#2ec4b6" };

		const SPEEDS = {
			slow: 900,
			normal: 600,
			fast: 300
		};

		// DOM
		const canvas = document.getElementById("board");
		const ctx = canvas.getContext("2d");
		const scoreEl = document.getElementById("score");
		const bestEl = document.getElementById("best");
		const speedEl = document.getElementById("speed");
		const overlay = document.getElementById("overlay");
		const overlayText = document.getElementById("overlayText");
		const resumeBtn = document.getElementById("resumeBtn");

		speedEl.addEventListener("click", () => {
			if (speedKey == "slow") {
				speedEl.textContent = "Normal";
				speedKey = "normal";
			}
			else if (speedKey == "normal") {
				speedEl.textContent = "Fast";
				speedKey = "fast";
			}
			else {
				speedEl.textContent = "Slow";
				speedKey = "slow";
			}
			if (!paused && !gameOver) startLoop();
		})

		// Game state
		let snake = [];
		let dir = { x: 1, y: 0 };          // moving right at start
		let nextDir = { x: 1, y: 0 };      // queued direction
		let food = { x: 10, y: 10 };
		let score = 0;
		let best = Number(localStorage.getItem("snake_best") || 0);
		let timer = null;
		let speedKey = "normal";
		let paused = false;
		let gameOver = false;

		bestEl.textContent = best.toString();
		speedEl.textContent = "Normal";

		function init() {
			score = 0;
			scoreEl.textContent = "0";
			gameOver = false;
			paused = false;
			overlay.style.display = "none";

			// Initialize snake centered
			const startX = Math.floor(GRID / 2);
			const startY = Math.floor(GRID / 2);
			snake = [];
			for (let i = START_LEN - 1; i >= 0; i--) {
				snake.push({ x: startX - i, y: startY });
			}
			snake.reverse()

			dir = { x: 1, y: 0 };
			nextDir = { x: 1, y: 0 };
			placeFood();
			startLoop();
			draw();
		}

		function startLoop() {
			stopLoop();
			timer = setInterval(tick, SPEEDS[speedKey]);
		}

		function stopLoop() {
			if (timer) {
				clearInterval(timer);
				timer = null;
			}
		}

		function tick() {
			if (paused || gameOver) return;

			// Apply queued direction
			dir = nextDir;

			// New head position
			const head = snake[0];
			const newHead = { x: head.x + dir.x, y: head.y + dir.y };

			// Wall collision
			if (newHead.x < 0 || newHead.y < 0 || newHead.x >= GRID || newHead.y >= GRID) {
				endGame();
				return;
			}

			// Self collision
			if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
				endGame();
				return;
			}

			// Move snake
			snake.unshift(newHead);

			// Eat or tail shift
			if (newHead.x === food.x && newHead.y === food.y) {
				score += 1;
				scoreEl.textContent = score.toString();
				if (score > best) {
					best = score;
					localStorage.setItem("snake_best", String(best));
					bestEl.textContent = best.toString();
				}
				placeFood();
			} else {
				snake.pop();
			}

			draw();
		}

		function endGame() {
			gameOver = true;
			stopLoop();
			overlayText.textContent = "Game Over";
			resumeBtn.textContent = "Restart";
			overlay.style.display = "grid";
		}

		function setPaused(val) {
			if (gameOver) return;
			paused = val;
			overlayText.textContent = "Paused";
			resumeBtn.textContent = "Resume";
			overlay.style.display = paused ? "grid" : "none";
			if (!paused) startLoop();
			else stopLoop();
		}

		function placeFood() {
			let x, y, collides;
			do {
				x = Math.floor(Math.random() * GRID);
				y = Math.floor(Math.random() * GRID);
				collides = snake.some(seg => seg.x === x && seg.y === y);
			} while (collides);
			food = { x, y };
		}

		function draw() {
			// Clear
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Optional soft grid lines for a retro feel
			ctx.strokeStyle = "rgba(255,255,255,0.05)";
			ctx.lineWidth = 1;
			for (let i = 1; i < GRID; i++) {
				// vertical
				ctx.beginPath();
				ctx.moveTo(i * CELL, 0);
				ctx.lineTo(i * CELL, GRID * CELL);
				ctx.stroke();
				// horizontal
				ctx.beginPath();
				ctx.moveTo(0, i * CELL);
				ctx.lineTo(GRID * CELL, i * CELL);
				ctx.stroke();
			}

			// Draw food
			drawCell(food.x, food.y, COLORS.food);

			// Draw snake
			for (let i = snake.length - 1; i >= 0; i--) {
				const seg = snake[i];
				const color = i === 0 ? COLORS.head : COLORS.snake;
				drawCell(seg.x, seg.y, color);
			}
		}

		function drawCell(x, y, color) {
			const pad = 2; // rounded cell inset
			ctx.fillStyle = color;
			roundRect(
				x * CELL + pad,
				y * CELL + pad,
				CELL - pad * 2,
				CELL - pad * 2,
				6
			);
			ctx.fill();
		}

		function roundRect(x, y, w, h, r) {
			ctx.beginPath();
			ctx.moveTo(x + r, y);
			ctx.arcTo(x + w, y, x + w, y + h, r);
			ctx.arcTo(x + w, y + h, x, y + h, r);
			ctx.arcTo(x, y + h, x, y, r);
			ctx.arcTo(x, y, x + w, y, r);
			ctx.closePath();
		}

		// Input handling
		const KEY_DIRS = {
			ArrowUp: { x: 0, y: -1 }, w: { x: 0, y: -1 },
			ArrowDown: { x: 0, y: 1 }, s: { x: 0, y: 1 },
			ArrowLeft: { x: -1, y: 0 }, a: { x: -1, y: 0 },
			ArrowRight: { x: 1, y: 0 }, d: { x: 1, y: 0 }
		};

		document.addEventListener("keydown", (e) => {
			const k = e.key;
			if (KEY_DIRS[k]) {
				const desired = KEY_DIRS[k];
				// Prevent reversing into itself
				if (snake.length > 1 && desired.x === -dir.x && desired.y === -dir.y) return;
				nextDir = desired;
				e.preventDefault();
				return;
			}

			if (k === "p" || k === "P") {
				setPaused(!paused);
			} else if (k === "r" || k === "R") {
				init();
			} else if (k === "1") {
				speedKey = "slow";
				speedEl.textContent = "Slow";
				if (!paused && !gameOver) startLoop();
			} else if (k === "2") {
				speedKey = "normal";
				speedEl.textContent = "Normal";
				if (!paused && !gameOver) startLoop();
			} else if (k === "3") {
				speedKey = "fast";
				speedEl.textContent = "Fast";
				if (!paused && !gameOver) startLoop();
			}
		});

		resumeBtn.addEventListener("click", () => {
			if (gameOver) init();
			else setPaused(false);
		});

		// Start
		init();
	</script>
</body>

</html>
